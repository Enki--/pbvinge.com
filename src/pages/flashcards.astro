---
import Layout from '../layouts/Layout.astro';
---
<Layout title="Flashcards">
  <style>
    :root {
      --card-w: min(720px, 92vw);
      --card-h: clamp(220px, 40vh, 360px);
      --radius: 12px;
      --card-shadow: 0 8px 20px rgba(0,0,0,.06);
      --focus: hsl(212 90% 56%);
    }

    /* Use site-wide variables for colors and font so the page matches Layout.astro */
    main.deck { min-height: 70vh; display:grid; place-items:center; padding: clamp(16px,3vw,48px); gap:18px }

    .stack { display: grid; gap: 18px; width: var(--card-w); }

   /* Make card height flow with content so controls naturally sit below it. Replace 3D flip
     with a simple cross-fade so answers can be large without fixed heights. */
   .card { width: 100%; position: relative; }

   .card__btn { display:block; width:100%; padding:0; border:0; background:transparent; cursor:pointer; transition: none; border-radius:var(--radius); box-shadow:var(--card-shadow); }
   .card__btn:focus-visible { outline: 3px solid var(--focus); outline-offset: 4px; }

   .card__face { display:grid; grid-template-rows:auto 1fr auto; align-items:start; gap:.5rem; padding:1.25rem 1.5rem; border-radius:var(--radius); background:var(--background-color); color:var(--text-color); transition: opacity .28s ease, transform .28s ease; }

   /* Back face visually distinct and left-aligned content for long answers */
   .card__face--back { background: color-mix(in srgb, var(--background-color) 92%, black 6%); text-align:left }

   /* show/hide faces with opacity (front visible when closed, back when open) */
   .card__face--front { opacity:1 }
   .card__face--back { opacity:0; pointer-events:none }
   .card__btn[aria-expanded="true"] .card__face--front { opacity:0; pointer-events:none }
   .card__btn[aria-expanded="true"] .card__face--back { opacity:1; pointer-events:auto }

    .card__eyebrow { font-size:.8rem; text-transform:uppercase; letter-spacing:.08em; opacity:.7 }
  .card__content { font-size: clamp(1.05rem, 1rem + .5vw, 1.25rem); align-self:center }
  /* back face: left-align long answers and allow them to stretch */
  .card__face--back .card__content { text-align:left; align-self:start }
    .card__hint { font-size:.9rem; opacity:.7 }

    .controls { display:flex; gap:12px; justify-content:center; align-items:center; width:100% }
    .controls button { background:transparent; border:1px solid color-mix(in srgb, var(--text-color) 12%, transparent 88%); color:var(--text-color); padding:.45rem .8rem; border-radius:8px; cursor:pointer }

    @media (prefers-reduced-motion: reduce) { .card__btn { transition: none } }

   /* Flashcard image layout: center under question and avoid cropping */
   .card__media { display:flex; flex-direction:column; gap:.75rem; align-items:center; justify-content:flex-start }
   .card__question-wrap { width:100%; }
   .card__image-wrap { width:100%; display:flex; justify-content:center }
   .card__image { display:none; width: clamp(160px, 40vw, 360px); height: auto; max-height: calc(var(--card-h) - 120px); object-fit: contain; border-radius:8px; }

   /* 3D flip shell + flipper. The shell gets an explicit height from JS so it can animate
     while the flipper performs the rotateY transform to produce a real 3D flip. */
   .card__shell { perspective: 1000px; width:100%; transition: height .32s ease }
   .card__flipper { transform-style: preserve-3d; transition: transform .6s cubic-bezier(.2,.6,.2,1); position: relative }
   .card__face { backface-visibility: hidden; -webkit-backface-visibility: hidden }
   .card__face--front { transform: rotateY(0deg); }
   .card__face--back { transform: rotateY(180deg); position: absolute; inset:0 } 
   .card__btn.is-flipped .card__flipper { transform: rotateY(180deg) }

   /* subtle content fade/slide when flipping */
   .card__face { transition: opacity .28s ease, transform .28s ease }
   .card__btn .card__face--front { opacity:1; transform: translateY(0) }
   .card__btn.is-flipped .card__face--front { opacity:0; transform: translateY(-6px) }
   .card__btn .card__face--back { opacity:0; transform: translateY(6px) }
   .card__btn.is-flipped .card__face--back { opacity:1; transform: translateY(0) }
  </style>

  <main class="deck">
    <h1>Flashcards</h1>

    <section class="stack" aria-label="Flashcard viewer">
      <article class="card" aria-labelledby="q-current">
        <!-- use a unique id for the back region to avoid accidental conflicts -->
        <button id="cardBtn" class="card__btn" type="button" aria-expanded="false" aria-controls="a-current-region">
          <div class="card__shell">
            <div class="card__flipper" aria-hidden="true">
              <div class="card__face card__face--front">
            <span class="card__eyebrow" id="eyebrow">Question</span>
            <div class="card__media">
              <div class="card__question-wrap">
                <div class="card__content" id="q-current">Loading…</div>
              </div>
              <div class="card__image-wrap" aria-hidden="true">
                <img id="cardImage" src="" alt="" loading="lazy" decoding="async" width="320" height="240" class="card__image" />
              </div>
            </div>
            <div class="card__hint">Click to reveal the answer</div>
        </div>

        <div class="card__face card__face--back" id="a-current-region" role="region" aria-label="Answer">
            <span class="card__eyebrow">Answer</span>
            <div class="card__content" id="a-current-content">Loading…</div>
            <div class="card__hint">Click to flip back</div>
              </div>
            </div>
          </div>
        </button>
      </article>

      <div class="controls">
  <button id="prevBtn" aria-label="Previous card">← Prev</button>
  <!-- placeholder progress (updated client-side) -->
  <div id="progress" style="opacity:.85">1 / —</div>
        <button id="nextBtn" aria-label="Next card">Next →</button>
      </div>
    </section>

    <p style="opacity:.75;max-width:var(--card-w);text-align:center">Tip: Click the card, press <kbd>Space</kbd> or <kbd>Enter</kbd> to flip. Use <kbd>←</kbd>/<kbd>→</kbd> to move between cards.</p>
  </main>

  <script>
    // Fetch flashcards JSON from public so we avoid any HTML-embedding/escaping issues
    let cards = [];
    async function loadCards() {
      try {
        const res = await fetch('/data/flashcards.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        cards = await res.json();
      } catch (err) {
        console.error('Failed to fetch flashcards.json', err);
        cards = [];
      }
      render();
    }

    let idx = 0;

    const btn = document.getElementById('cardBtn');
    const qEl = document.getElementById('q-current');
    const aEl = document.getElementById('a-current-content');
    const eyebrow = document.getElementById('eyebrow');
    const progress = document.getElementById('progress');
    const prev = document.getElementById('prevBtn');
    const next = document.getElementById('nextBtn');
    const cardImage = document.getElementById('cardImage');

    // Basic sanity checks
    if (!btn || !qEl || !aEl || !progress) {
      console.error('Flashcards: missing required DOM elements', { btn, qEl, aEl, progress });
    }

    function render() {
      if (!cards || cards.length === 0) {
        qEl && (qEl.textContent = 'No cards available');
        aEl && (aEl.textContent = '');
        progress && (progress.textContent = '0 / 0');
        return;
      }

      // wrap index if out of range
      idx = ((idx % cards.length) + cards.length) % cards.length;

      const c = cards[idx];
      qEl.textContent = c.q || '';
      aEl.textContent = c.a || '';
      eyebrow.textContent = `Question ${idx + 1}`;
      progress.textContent = `${idx + 1} / ${cards.length}`;

      // always reset to closed on render
      btn && btn.setAttribute('aria-expanded', 'false');

      // image handling
      if (c.img && cardImage) {
        // Prefer https to avoid mixed-content blocking in browsers
        let imgUrl = c.img;
        if (imgUrl.startsWith('http://')) imgUrl = imgUrl.replace(/^http:\/\//, 'https://');
        cardImage.src = imgUrl;
        cardImage.alt = c.q || '';
        // ensure the img is visible and respects its CSS sizing
        cardImage.style.display = 'block';
      } else if (cardImage) {
        cardImage.removeAttribute('src');
        cardImage.alt = '';
        cardImage.style.display = 'none';
      }

      console.debug('Flashcards: rendered', { idx, total: cards.length, card: c });
    }

    // 3D flip handling with dynamic height
    const shell = document.querySelector('.card__shell');
    const flipper = document.querySelector('.card__flipper');
    const frontFace = document.querySelector('.card__face--front');
    const backFace = document.querySelector('.card__face--back');

    function measureHeights() {
      if (!frontFace || !backFace || !shell) return { front: 0, back: 0 };
      // Temporarily reset shell height so natural content sizes compute correctly
      const prevHeight = shell.style.height;
      shell.style.height = 'auto';
      // ensure backFace is not interfering with layout when measuring
      backFace.style.display = 'block';
      backFace.style.position = 'relative';
      backFace.style.transform = 'none';
      frontFace.style.position = 'relative';
      const frontH = frontFace.getBoundingClientRect().height;
      const backH = backFace.getBoundingClientRect().height;
      // restore
      backFace.style.position = '';
      backFace.style.transform = '';
      shell.style.height = prevHeight;
      return { front: Math.round(frontH), back: Math.round(backH) };
    }

    let heights = { front: 0, back: 0 };
    function updateHeights() {
      heights = measureHeights();
      // set shell height to currently-visible face
      const open = btn && btn.getAttribute('aria-expanded') === 'true';
      const target = open ? heights.back : heights.front || heights.back || 0;
      if (shell) shell.style.height = target ? `${target}px` : 'auto';
    }

    if (btn) {
      btn.addEventListener('click', (e) => {
        const open = btn.getAttribute('aria-expanded') === 'true';
        // compute heights before toggling so we can animate
        updateHeights();
        // next height
        const nextHeight = open ? heights.front : heights.back || heights.front;
        // apply flip class
        if (open) {
          btn.classList.remove('is-flipped');
        } else {
          btn.classList.add('is-flipped');
        }
        btn.setAttribute('aria-expanded', String(!open));
        // animate height
        if (shell && nextHeight) {
          // force reflow to ensure transition
          void shell.offsetHeight;
          shell.style.height = `${nextHeight}px`;
        }
        console.debug('Flashcards: toggled', { idx, open: !open });
      });
    }

    // recalc heights when images load or window resizes
    function attachImageListeners() {
      if (!cardImage) return;
      cardImage.addEventListener('load', () => { updateHeights(); });
    }
    attachImageListeners();
    window.addEventListener('resize', () => { updateHeights(); });

    // use code/key values for reliable handling
    document.addEventListener('keydown', (e) => {
      const activeIsBtn = document.activeElement === btn;
      if (e.code === 'ArrowRight' || e.key === 'ArrowRight') { idx = (idx + 1) % cards.length; render(); btn && btn.focus(); return }
      if (e.code === 'ArrowLeft' || e.key === 'ArrowLeft') { idx = (idx - 1 + cards.length) % cards.length; render(); btn && btn.focus(); return }

      // space/enter toggles when the card button is focused
      if (activeIsBtn && (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter')) {
        e.preventDefault();
        const open = btn.getAttribute('aria-expanded') === 'true';
        btn.setAttribute('aria-expanded', String(!open));
        return;
      }
    });

    prev && prev.addEventListener('click', () => { idx = (idx - 1 + cards.length) % cards.length; render(); btn && btn.focus() });
    next && next.addEventListener('click', () => { idx = (idx + 1) % cards.length; render(); btn && btn.focus() });

    // initial load + render after fetch
    render();
    loadCards();
  </script>
</Layout>
